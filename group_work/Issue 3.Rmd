---
title: "Group assignment #3"
author: "Tanja Dreiser, Jonas Materna and Dorothee Ohlrogge"
date: "9/13/2020"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(tidyverse)
library(knitr)
library(kableExtra)
library(stringr)
library(stringdist)
library(ggplot2)

Sys.setlocale("LC_ALL", "UTF-8")
```

### Data cleaning
First, read the Insolvecy and Orbis data. 

```{r readInsol}
insol_raw <- read_csv(
  "../raw_data/insolvency_filings_de_julaug2020.csv",
  col_types = cols(), locale = readr::locale(encoding = "UTF-8")
)
```

```{r readOrbis}
orbis_raw <- read_csv(
  "../raw_data/orbis_wrds_de.csv",
  col_types = cols(), n_max = 100000
)
```
The Insolvency (Orbis) dataset contains `r length(which(duplicated(insol_raw)))` (`r length(which(duplicated(orbis_raw)))`) duplicates. Let's delete them.

```{r deleteDups, results = "hide"}
insol_de <- insol_raw %>% unique()
orbis_de <- orbis_raw %>% unique()
```


For our analysis we want to have a closer look at firms that filed for insolvency (subject == Eröffnungen):

```{r getOpenings, results = "hide"}
insol_open_de <- insol_de[insol_de$subject == "Eröffnungen",]
```


Fuzzy match based on international names excluding umlauts.

```{r replaceUmplauts, results = "hide"}
internat_name <- insol_open_de$name_debtor
internat_name <- str_replace(internat_name, "Ä","Ae")
internat_name <- str_replace(internat_name, "Ö","Oe")
internat_name <- str_replace(internat_name, "Ü","Ue")
internat_name <- str_replace(internat_name, "ä","ae")
internat_name <- str_replace(internat_name, "ö","oe")
internat_name <- str_replace(internat_name, "ü","ue")

#Remove duplicates and the "(haftungsbeschraenkt)" tag
internat_name <- unique(internat_name)
internat_name <- str_replace(internat_name, "\\(haftungsbeschraenkt\\)", "")

```


Try to find a match for each insolvent company in the orbis universe. To do this the Damerau-Levenshtein distance is applied.

```{r fuzzyMatchFunction, results = "hide"}
ClosestMatch = function(string, stringVector, maxDist){
  
  match <- stringVector[amatch(string, stringVector, 
                               method = "dl",
                               maxDist=maxDist)]
  
  if(!is.na(match)){
    which(stringVector == match)
  }
}
```


The restrictiveness of the matching is based on the length of the firm name. We are super restrictive for short names.

```{r fuzzyMatch, results = "hide"}

insol_filers <- data_frame()
pb <- txtProgressBar(min = 0, max = length(internat_name), style = 3)
insol_filer <- rep(0, length(orbis_de$X1))
for(i in 1:length(internat_name)){
  
  rowno <- "NA"
  #Look for exact match
  rowno <- which(orbis_de$name_internat == internat_name[i])

  if(!length(rowno)>0){
    
    if(nchar(internat_name[i])<=15){
      rowno <- ClosestMatch(internat_name[i], orbis_de$name_internat, 0.1 )
    }
    
   if(nchar(internat_name[i])>15 && nchar(internat_name[i])<=30 ){
      rowno <- ClosestMatch(internat_name[i], orbis_de$name_internat, 2 )
   }
    
   if(nchar(internat_name[i])>30){
      rowno <- ClosestMatch(internat_name[i], orbis_de$name_internat, 4 )
   }
    

  }
    
    #If there is a match save it
    if(length(rowno)>0){
      insol_filers <- rbind(insol_filers, orbis_de[rowno,])
      insol_filer[rowno] <- 1
    }
  setTxtProgressBar(pb, i)
}
```

Now analyse how the insolvent firms differ from the unisverse of firms.

Calculate the ratio of current liabilities to total liabilities.

```{r CLTL, results = "hide"}
CLTL_universe <- orbis_de$culi/(orbis_de$culi + orbis_de$ncli)
CLTL_insol    <- insol_filers$culi/(insol_filers$culi + insol_filers$ncli)

CLTL_universe_mean <- aggregate(CLTL_universe, list(orbis_de$year), function(x) mean(x, na.rm=TRUE))
CLTL_insol_mean    <- aggregate(CLTL_insol, list(insol_filers$year), function(x) mean(x, na.rm=TRUE))

CLTL_universe_mean$insol <- "Universe"
CLTL_insol_mean$insol    <- "Insolvent Firms"
CLTL <- rbind(CLTL_universe_mean[CLTL_universe_mean$Group.1 > 2004,], 
                   CLTL_insol_mean[CLTL_insol_mean$Group.1 > 2004,])

colnames(CLTL)     <- c("Year", "Mean", "Insolvency")
```

Plot the ratios

```{r CLTLPlot}


ggplot(CLTL, aes(x=Year, y=Mean, col=Insolvency)) +
 geom_line() +
 ggtitle("Current Liabilities to Total Liabilities") +
 theme(plot.title = element_text(hjust = 0.5))


```
generate a Dummy for Insolvency
```{r Dummy}
orbis_de$insolvent <- 0
orbis_de$insolvent <- orbis_de$bvdid %in% insol_filers$bvdid
orbis_de$insolvent [orbis_de$insolvent==TRUE] <- 1
orbis_de$insolvent [orbis_de$insolvent==FALSE] <- 0
```
Gerate different ratios
```{r Ratios}
orbis_de$gross_profit <- (orbis_de$turn-orbis_de$cost)/orbis_de$turn
orbis_de$ROA <- orbis_de$pl/orbis_de$toas
orbis_de$ROE <- orbis_de$shfd/orbis_de$toas
orbis_de$profit_employee <- orbis_de$pl/orbis_de$empl
orbis_de$current_ratio <- orbis_de$cuas/orbis_de$culi
orbis_de$debt <- (orbis_de$culi + orbis_de$ncli)/orbis_de$toas
orbis_de$leverage <- orbis_de$shfd/(orbis_de$culi + orbis_de$ncli)
orbis_de$growth_assets <- (orbis_de$toas-lag(orbis_de$toas))/lag(orbis_de$toas)
orbis_de$size <- log(orbis_de$toas)

```
Profit Margin
```{r ProftiMargin}
orbis_de$gross_profit <- (orbis_de$turn-orbis_de$cost)/orbis_de$turn
t.test(orbis_de$gross_profit[orbis_de$insolvent==1],orbis_de$gross_profit[orbis_de$insolvent==0])

#Irgendwas stimmt bei dem Plot noch nicht ganz...
ggplot(orbis_de[!is.na(orbis_de$gross_profit),], aes(x=year)) +
 geom_line(aes(y=gross_profit, color=insolvent)) +
 ggtitle("Profit Margin") +
 theme(plot.title = element_text(hjust = 0.5))
